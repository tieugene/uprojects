rpl:
		2904000000000000
Provides:
	rpm -q --provides:
		rpl
	Providename:
		rpl	2904000000000000
Requires:
	rpm -q --requires:
		rpmlib(PayloadFilesHavePrefix)
		rpmlib(CompressedFileNames)
		libc.so.6
		libc.so.6(GLIBC_2.0)
		libc.so.6(GLIBC_2.1)
	Requirename:
		libc.so.6			2904000002000000
		libc.so.6(GLIBC_2.0)		2904000003000000
		libc.so.6(GLIBC_2.1)		2904000004000000

Tools:
	rpm -qa --queryformat "%{NAME}\n" | sort > rpms.txt
	rpm -q --requires <...>
	rpm -q --provides <...>
Files:
	Name
	Providename
	Requirename
Test:
	rpm:
		ID = 7901000000000000
	Provides:
		config(rpm)	(Providename value = 7901000000000000)
		rpm		(Providename value = 7901000001000000)
		=> value = key((4 bytes << 4)) | provideno (0...)
		=> value = u_int16_t (package).u_int16_t[provno]
	Requires:
Format:
	Name:	package names
		key:	string	package name
		value:	string(8):
			int(4)	ID - 1..$(rpm -qa | wc -l)
			int(4)	0
	Providename:	list of services, provided by each package
		key	string	servicename
		value:	string(8x) - pairs of:
			int(4)	Name ID package no, whot provides this service
				(can B misc - e.g.
				vim-X11-gui	:
				vim-X11-neXtaw	0x408
				vim-X11-gtk2	0x409
				but can B duplicated)
			int(4)	Provide # in `--provides` list of package
	Requirename:	list of services, required by each package
		key	string	servicename
		value:	string(8x) - pairs of:
			int(4)	Name ID package no, what requires this service
			int(4)	# in `--requires` list of package

Trash:
def	w2h(s):
	'''converts string[8] to hex'''
	return "%02X%02X%02X%02X%02X%02X%02X%02X" % (ord(s[0]), ord(s[1]), ord(s[2]), ord(s[3]), ord(s[4]), ord(s[5]), ord(s[6]), ord(s[7]))

def	s2h(s):
	h = ''
	sep = ''
	for i in xrange(len(s) / 8):
		h = h + sep + w2h(s[(i*8):])
		sep = ' '
	return h

Notes:
	Рассмотрим случаи requires vs provides:
	* Rq:(2), Pr:(x) [1:0] - requires that nobody provides
		* Error? (or skip)
	* Rq(*), Pr(?) [*:1.*] - requires by one provider
		* Rq(2), Pr(3) [1:1.e] - requires by other (trivial)
			* Pkg[2]:Rq=True
		* Rq(1, 2, 3), Pr(5) [M:1.e] - requires by others
			Pkg[1, 2, 3].Rq = True
		* Rq(2), Pr(2) [1:1.i] - requires by provider
			* Rq(2) - skip
		* Rq(1, 2, 3), Pr(2) [M:1.i] - requires by others and provider
			* Rq(2) - skip, Pkg[1, 3].Rq = True
	* Rq(*), Pr(?) [*:M.*] - requires by multiprovider
		* Rq(2), Pr(5, 6, 7) [1:M.e] - requred proveded by many alternatives
			* Pkg[2].Alt = True
		* Rq(2), Pr(1, 2, 3) [1:M.i] - required by one from alternative provider
			* Rq(2) - skip
		* Rq(1, 2, 3), Pr(5, 2, 6) [M:M.i] - requires by many and provider in
			* Rq(2) - skip, Pkg[1, 3].Alt = True
		* Rq(1, 2, 3), Pr(5, 6, 7) [M:M.e] - requires by many; provided by othres any
			* Pkg[1, 2, 3].Alt = True
================
Всё будет не так
----------------
. Необходимо обеспечить поиск (p == packet, s == service):
  .. P > S.Provided
  .. P > S.Required
  .. S > P.Provider (> alternate)
  .. S > P.Requirer (> top)
. Для этого создаются arrays:
  .. Pkg: [(name, [S.P,], [S.R]),]
  .. Svc: [(name, [P.P,], [P.R]),]
. Поиск:
  .. P > S.P:
	P[i][1]
  .. P > S.R:
	P[i][2]
  .. P > P
	for i in P[...][2]:
		for j in S[i][1]:
			print p[j][0]
. Design:
  * just 1 window
  * left - pkg list (sorted by AB)
  * mid - services:
    - up - required
    - dn - provided
  * right - pkgs
    - up - required
    - dn - provided
. Algorythm
  * get data
    - pkg
	# 1. load
	for i in Name:
		name = key
		N = value
		P_hash[name] = N	# hash name:N
	# 2. create array of P and 'oldN>newN'
	for pname in P_hash.keys().sort():
		P.append((p, [], []))	# packages
		PON.append(0)		# grow empty 'package oldN-to-newN
	# 3. fillout PON
	for i in xargs(len(P)):		# each Pkg no
		PON[[P_hash[P[i][0]][1]] = i	# a) get P-newN, b) get his name, c) find oldN by name, d) store oldN
    - svc
	# 1. provides
	for i in Provide...:
		name = key
		v = parsevalue(value)
		tmp = []
		for j in v:		# each Pkg no
			tmp.append(PON[j])	# translate by PON
		S_hash[tmp[0]] = (name, tmp, [])
	# 2. requires
	for i in Require...:
		name = key
		v = parsevalue(value)
		tmp = []
		for j in v:		# each Pkg no
			tmp.append(PON[j])	# translate by PON
		if (S_hash.has_key(name):
			S_hash[tmp[0]][2].expand(tmp)
		else:
			S_hash[tmp[0]] = (name, [], tmp)
	# 3. rebuild
