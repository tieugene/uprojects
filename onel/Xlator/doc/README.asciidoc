Xlating 1C:Basic into Python
============================
Eugene A. Pivnev <ti.eugene@gmail.com>
ver. 0.1, 11 July 2006

== Aims
=== Strategy
Make Python as 1L working language (one from !)

=== Tactic
Convert 1C:Basic texts into Python scripts (причем, ближе в Python).

== Objects
* Global:
  -- Module
  -- Tables
    . Calculated cells
* Objects footnote:[Объект (Документ, Расчет)]:
  -- Module
* Form
  -- Module
  -- Dialog
    . Calculated fields
  -- Tables
    . Calculated fields

== PreProcessing
...

== Translation

=== Legend footnote:[Условные обозначения]
  * E  == English (с сохранением регистра)
  * R  == Russian (с сохранением регистра)
  * LE == Little only English
  * LR == Little only Russian
  * S  == Source
  * C  == Converted

=== Input (Вход) - для:
  * Глобальные
    -- Модуль
    -- Таблица
  * Модуль объекта
  * Форма
    -- Модуль
      . словари:
        .. Системные:
          -- переменные (E, R)
          -- методы (E, R)
        .. глобальные (объявленные Экспорт):
          -- переменные (S, C)
          -- методы (S, C)
        .. модуль:
          -- переменные (S, C)
          -- методы (S, C)
          -- предопределенные (S, C)
        .. формы:
          -- поля (name (S, C), synonym (S, C))

=== 1C syntax
(TODO: Move to translation)
  * Operators:
    ~метка:Оператор[(параметры)] ДобКлючевоеСлово;
  * Module structure:
    * Variables definition
    * Function/procedures
    * main program
  * Special symbols:
	//	начинается комментарий. Комментарием считается весь текст от знака "//" до конца текущей строки.
	|	начале строки используется только в строковых константах и означает, что данная строка является продолжением предыдущей (перенос строки), (см. "Строковые константы").
	~	начинается метка оператора.
	:	заканчивается метка оператора.
	;	символ разделения операторов.
	( )	список параметров методов, процедур и функций.
	[ ]	размерность массивов.
	,	разделяет параметры в списке параметров методов, процедур и функций.
	" "	заключаются строковые константы.
	' '	заключаются константы даты.
	.	Десятичная точка в числовых константах. Разделитель, используемый в описаниях агрегатных типов данных.
	+	операцию сложения.
	-	операцию вычитания.
	*	операцию умножения.
	/	операцию деления.
	%	остаток от деления
	>	логическую операцию "больше".
	>=	Логическая операция "больше или равно".
	<	логическую операцию "меньше".
	<=	Логическая операция "меньше или равно".
	=	присвоение или логическую операцию "равно".
	<>	логическую операцию "не равно".
  * объявление переменной:
    var <name>[[size]] [Export]
  * Процедура:
	Procedure <name>([[Val] <arg1>[=<defval>], ... , [Val] <valN>[=<defval>]]) [Export]
	//Объявления локальных переменных;
	//Операторы;
	...
	[Return;]
	//Операторы;
	...
	EndProcedure
or
	Procedure <name>([[Val] <arg1>[=<defval>], ... , [Val] <valN>[=<defval>]]) Forward
  * число
	[+|-]{0-9}[.{0-9}]
  * дата
	'ДД.ММ.ГГ' или 'ДД.ММ.ГГГГ'
  * строки:
    * однострочные:
	"..."
    * многострочные-1 (В данном случае между фрагментами, представляющими отдельные строки многострочной константы, не должно встречаться никаких символов, за исключением пробелов, переводов строки и строк комментариев.)
	Стр = "Первая строка"    // пример строковой константы
	"Вторая строка"
	"Третья строка";
    * многострочные-2 (В данном примере значение константы полностью идентично предыдущему примеру. Отличие заключается в том, что каждая отдельная составляющая не замыкается кавычками, а на каждой последующей строке помещен символ переноса строки "|". В этом варианте комментарии между открывающей и закрывающей кавычками не допускаются.)
	Стр = "Первая строка
	|Вторая строка
	|Третья строка";

=== Algorythm
. lexical analizer (лексический анализатор) - разбиение на токены
. syntactic analyzer синтаксический анализатор) - построение синтаксического дерева
. semantic analizer (семантический анализ) - ...
. codegeneration (кодогенерация) - генерация исходника на Python (русские наименования приведены в kw.txt):
  * конструкции языка:
    -- Comments
      1C::
	// ... (и до конца строки)
      Python::
        # ...
    -- окончание оператора
      1C::
        ;
      Python::
        \r ? ;
    -- Date constants (константы даты)
      1C::
        'DD.MM.YY[YY]'
      Python::
        Date('DD.MM.YY[YY]')
    -- variable declaration (объявления переменных)
      1C::
        Var[ Export] <name>)
      Python::
        <var> = None
    -- Procedure/Function declaration (объявления процедур)
      1C::
        Procedure[ Export] <name> ... EndProcedure
        Function[ Export] <name> ... EndFunction
      Python::
        def ...
      1C::
        Procedure[ Export] Forward
        Function[ Export] Forward
      Python::
        def
    -- объявления функций (Функция|Function[ Export]..return..EndFunction) => def..return
      . передача параметров по сцылке => semiauto (полуавтоматическая обработка) - см. PostProcessing
      . передача параметров по значению (Val(<name>)) => <name>
    -- зарезервированные слова (reserved.txt) - .. (make special table)
      1C::
      Python::
    -- основная программа модулю => спецфункция - типа _init; только проследить, чтобы:
      . не было пересечений
      . вызывалась после загрузки модуля
    -- Условия (if..then..elseif..else..endif) => if..elif..else
      1C::
      Python::
    -- Цикл:
      1C::
      Python::
      . for a=b to c do...enddo => for a in xrange(..)
      . while..do...enddo => while
      . continue => continue
      . break => break
    -- Try..Except..EndTry => try..except..
      1C::
      Python::
    -- Label (Метка):
      1C::
      Python::
      . Definition (объявление): ~<name> => handle processing (ручная обработка)
      . Call (Вызов): Goto <mark> => handle processing (ручная обработка)
    -- Special:
      . #ЗагрузитьИзФайла => ?import?
  * indents (отступы)
      1C::
      Python::
    -- в соответствии с конструкциями языка; 1 x <tab>/identотступ
  * members:
    -- Naming
      . E (English) => e_<as_is>
      . R (Russian) => r_<translit>
    -- System:
      . variables/objects => E
      . methods => E
    -- global ($GLOBAL == (e.g.) Global):
      . variable <name> => GLOBAL.<name>
      . method <name>:
        .. predefined => E
        .. userdefined =>
          * E => e_LE
          * R => translit => r_LE)
      . yet another thoughts (всякие мысли):
	.. область переменных - надо как-то обрабатывать
	.. Var <name> Export => ...
	* Global.register("a") |
	* a = None | ...
	* global.__dict__["a"] = None
	.. Var a => ...
	.. functions/procedures - need 2 B split...
	* definition
	* member's call: lvalue/rvalue x var/func x std/global/userdef
    -- Module:
      * variables
      * methods:
        * predefined => E
	* userdefeined => r|e_LE
    -- Forms:
      * fields => Form.<f_LE>.Value

=== Output (Выход) - во что (физически) превращаются
  * Global
    -- Module
    -- Table fields
  * Objects (Documents, Обработка):
    -- Module
  * Form
    -- Module
      . System:
        .. variables/objects
        .. methods
      . Global
        .. variables/objects
        .. methods
      . This module
        .. variables/objects
        .. methods
      . Dialog
        .. Calculated fields
      . Table
        .. Calculated fields

== Running (Исполнение)
=== Common (Общий порядок)
  . Analize (анализ)
  . split on funcs (разбиение на функции)
  . compile each (компиляция каждой ф-ции отдельно в байт-код)
  . insert into *.__dict__ (подстаовка вызовов ф-ций в нужный словарь)
=== Features (Особенности)
  * системные => глобальный контекст (from lw... import *)
  * глобальные => глобальный контекст (?)
  * поля формы

== Features (Особенности)
Differences between 1C:Basic & Python:
  * Порядок обхода контекста:
    * 1C - глобальный, глобальный модуля, локальный ф-ции <> поля
    * Python - ...
  * ...

== Notes
=== Василий Здановский 6322
Тебе только надо распределить ИМЕНА переменных по трем пространствам
(EAP: еще бы вызвать их правильно...)
Модуль формы, сам объект (в 8-ке ЭтотОбъект), РеквизитыФормы, Сама морда непосредственно.
Причем в 77 есть последовательность обхода, в 8-ке все вааще явно указывается.
Делаешь в модуле формы соотв. ассоц. массивы + массивы методов и сводишь все к вызовам, которые я тебе описал.
В методах все аналогично, только массив модуля копируется и переменные маскируются.
Для получения списка имен пропиши: isName - возвращает может ли данное сочетание символов быть именем, isFuncColl - функцией, isFieldName - полем объекта, isMethodCall - вызов метода. Функции маленькие, поскольку базируются на первых двух. Дальше -проход по тексту модуля и создание списка методов и переменных модуля, потом проход по каждой функции. В итоге, можно свести весь текст модуля к выражениям на питоне с разруливанием по именам.
Это не сложно.
Я не описал глобальный модуль. Но, он компилится так же.  И маскируется массивом переменных модуля так же, как и в сл. разбора методов.
Еще раз повторяю - я просто обещал. Чуть позже сброшу
Но пока проект не завершен. Не могу. Просто не хочу рисковать. 
А именно этот парсер в нем и прописан. Клиент хотел, чтобы уникальность кода, который для него прописывается, была соблюдена. 
Если не дай Бог это выплывет - мне хоть в петлю лезь. Потому как бабки заплачены немалые.
Кстати сказать такой подход хоть и будет тормознутым, зато даст возможность легко подстраивать 1Л под изменения языка 1С в дальнейшем.   

== 6410 ==
  * Global Module:
    * Вход:
      * текст
      * словарь системных методов, атрибутов и их методов
      * словарь predefined методов
    * Преобразование:
      * Converting(): Name export => e_Name | Name => __e_Name | Имя Экспорт => r_Imya | Имя => __r_Imya
      * Перем:
        * if (system attribute): error
        * else: Converting()
      * StatList => _init()
      * Function Name (a, b, val c) Export:
        * if (predefined_global): name = dict[name]
        * elif (keyword or system): error
        * else: Converting(); store src:dest	# т.е. речь о том, чтобы словари _никогда_ не пересекались - только в predefined
        * (...val c) => (...c) - или придумать механизмы. Как варианты:
          * a, b = Name(a, b, val c)
          * a = globalstorage(1); b = globalstorage(2); Name(a, b)
        * Var e, f => e = None; f = None
        * вызовы глобальных переменных (но _не_ аргументов и _не_ Var) - предварить "global ..."
        * вызовы к системным членам - по словарю (?)
    * Выход:
      * словарь переменных export (старое и новое имя)
      * словарь методов export
    * misc
        * maybe словарь системных - 3 части:
          * атрибуты (Name | Name\.*)
          * ф-ции (Name(*)
          * методы атрибутов (\.Name())

=== mybuh
==== nota_bene.txt
* создаем class FormControlElem - объект в котором хранится информация об одном контроле(элементе формы), взятая из Dialog Stream ert-модуля
* //// с числами не все так просто .... пример:
    R_a = 2.356
    R_a = R_a + 3.897; #
    R_a = R_a - 4.14; #
    R_a = R_a * 5; #
    R_a = R_a / 10.0; # 
    #Сообщить(А)
    #print R_a,type(R_a) здесь print показывает 1.0565, но сравнение не проходит, если убрать round !!!!!
    R_a = round(R_a,4)
    #print R_a,type(R_a)

    if ( R_a != 1.0565 ):
        Buh.Message("КЯ:012:Неверный результат математических вычислений" + Buh.String(R_a))
  нужно учитывать при конвертации...
  и что главное - даже если поставить round(...,15) - уже проходит...
* ГЛЮК СО СЛОЖЕНИЕМ СТРОК В ПИТОНЕ:
  StrOfQuery = "UPDATE " + self.CurrSpecifier.TblName + " SET "
    print StrOfQuery + "*****фы"
  выбрасывает ошибку (не всегда):
    UnicodeDecodeError: 'ascii' codec can't decode byte 0xf4 in position 5: ordinal not in range(128)
  ЛЕЧИТСЯ:
    print str(StrOfQuery) + str("*****фы")
* РАБОТА С ФОРМОЙ (диалогом).
  Так как не получится сделать как в 1С (например, если на форме есть поле "Цена"), то из модуля можно делать :
  читать:
    ВремЦена = Цена
  и писать:
    Цена = 100.25),
  именно писать и не получится, так как будет создан новый объект и на форме ничего не изменится...
  ПОЭТОМУ !!!
  Делаем классы Dlg() и Tbl() для доступа к форме и таблице соответственно со своим контролем атрибутов...
  Поэтому после трансляции придется соответственно изменить исх. текст модуля.
  Т.е. вместо Цена = 100.25 будет Dlg.R_cena = 100.25
* Аналогично и с таблицей.
* 13.06.05 Сделан спец.контрол buh_tbctrl.TextBtnCtrl - текстовое поле с кнопкой для выбора значений "бух" - типов данных.
  ВНИМАНИЕ! Его нельзя размещать на модальных диалогах - в Линуксе он не перехватывает фокус и в итоге не воспринимает ввод с мыши и клав-ры
* было выполнено тестирование sqlite и pysqlite1.16 с pdo и без.
* Проблема - даже при указании типа поля BIGINT UNSIGNED записать число больше 10 разрядов (1234567890) не получается(пишет но выводит потом неверно).
  Поэтому sqlite подойдет только для небольших баз (примерно до 10 млн.строк в одной таблице, с учетом что два последних знака - BaseID, т.е. код базы)
* было выполнено тестирование PostgreSQL8.0 и PyGreSQL-3.6.1 с pdo и без.
  Проблема - для BIGINT не понимает UNSIGNED
* Также проблема с кавычками. 
  Так неправильно:
    db.execute('INSERT INTO t5 (o_id, f01) VALUES(1234567890, "apple")')
  а так правильно:
    db.execute("INSERT INTO t5 (o_id, f01) VALUES(1234567890, 'apple')")

==== translating.txt
* поубирал все периодические константы и реквизиты справочников...
* поубирал слои на формах...
* Атрибут документа Операция использовать ТОЛЬКО в модуле проведения

==== transl_specif.txt
* Перед трансляцией подобавлять в модулях по одной пустой строке в конце текста программного модуля, иначе если конец файла находится в непустой строке - то глюки при трансляции этого модуля
* Желательно оставить только русские ключевые слова. Английские поубирать.
* В самом простом описании транслятор переводит русские 1С-ключевые слова в английские 1С-ключевые слова согласно "описанию встроенного языка". Русские идентификаторы переменных переводятся методом транслитерации в английские с добавлением префикса "R_". Возможно, в-дальнейшем, этот префикс не будет добавлятся в случае, если переведенный идентификатор "не пересекается" с ключевыми словами. Нужно подумать...
* В модулях формы к идентификаторам элементов диалога добавляется префикс "dlg.", а к идентификаторам табличной части диалога добавляется префикс "tbl.".
* В модулях проведения документов и к идентификаторам элементов диалога , и к идентификаторам табличной части диалога добавляется префикс "Context."
* Во все модулях кроме глобального, к идентификаторам функций и переменных, которые экспортируются из глоб.модуля, добавляется префикс "glob_mod."
* глобальные переменные (описанные в блоке Перем модуля) не нужно передавать в качестве аргументов функций, на то они и глобальные, меньше путаницы...
* а ссылочные аргументы в 1С нужно переделать так:
  было :
	Если Функ(А1,А2) = 10 тогда
		А3 = А1 + А2
	КонецЕсли;
  переделываем:
	Рез = Функ(А1,А2);
	Если Рез = 10 тогда
		А3 = А1 + А2
	КонецЕсли;
  Мелочь, но зато головняка намного меньше...
* Желательно, там где можно в функциях с параметрами ставить "Знач", особенно когда параметров много.
* Функции Мин и Макс заменяются на Питоновские, которые не преобразовуют типы к одному виду, поэтому например 123 и "345" сравниваются не так как в 1С...
* Строковые функции AnsiToOem и OemToAnsi - не работают, возвращают исх. строку
* Тело модуля 1С (которое внизу, после всех процедур и функций) не обрабатывается, поэтому в исх. конфах его нужно переместить в процедуру ПриОткрытии()
* блок :
	Если сз.Принадлежит("Значение444") = 1 тогда
		//Сообщить("СЗ: Проверка на принадлежность строкового значения - успешно...");
	иначе
		Сообщить("СЗ:098: Проверка на принадлежность строкового значения - неверно !!!");	
	КонецЕсли;
  преобразуется в :
	if ( R_sz.Belong("""Значение444""") == 1 ):
		#Сообщить("СЗ: Проверка на принадлежность строкового значения - успешно...")
	else:
		bMessage("""СЗ:098: Проверка на принадлежность строкового значения - неверно !!!""")
  что выдает ошибку после строки с if (нужен какой-нибудь оператор)...
  исправляем :
	Если сз.Принадлежит("Значение444") = 1 тогда
		ПустаяПеременная = 0;
		//Сообщить("СЗ: Проверка на принадлежность строкового значения - успешно...");
	иначе
		Сообщить("СЗ:098: Проверка на принадлежность строкового значения - неверно !!!");	
	КонецЕсли;
* опущенные аргументы функций при вызове :
	f3(1,,1)
  будут заменятся на None
	f3(1,None,1)
  потому что Питон не допускает пропущенных аргументов...
* ...
	Функция РасчетНадбавки (СтараяЦ,ПроцН) Экспорт
		// ________ Функция возвращает новую сумму с учетом старой и процента надб./скидки
		Если ПроцН = 0 тогда
			Возврат СтараяЦ;
		Иначе Возврат СтараяЦ*(100+ПроцН)/100;
		КонецЕсли;
	КонецФункции 
  переделываем:
	Функция РасчетНадбавки (Знач СтараяЦ, Знач ПроцН) Экспорт
		// Функция возвращает новую сумму с учетом старой и процента надб./скидки
		Если ПроцН = 0 тогда
			Возврат СтараяЦ;
		Иначе 
			Возврат СтараяЦ*(100+ПроцН)/100;
		КонецЕсли;
	КонецФункции 
* ...
	Если СокрЛП(ВРег(зн))<>"ааа" Тогда
		Возврат 0;
	Иначе
  переделываем--- :
	Если СокрЛП(ВРег(зн)) <> "ааа" Тогда
		Возврат 0;
	Иначе
* ...
	Str0 = "Добро пожаловать! Сегодня " + ДеньНеделиПрописью(ТекущаяДата())
	+ " " + ТекущаяДата() + РазделительСтрок +"Сейчас установлен  курс УДЕ="
	+ Вв.Курс.Получить(ТекущаяДата());
  переделываем--- :
	Str0 = "Добро пожаловать! Сегодня " + ДеньНеделиПрописью(ТекущаяДата()) ;
	Str0 = Str0 + " " + ТекущаяДата() + РазделительСтрок +"Сейчас установлен  курс УДЕ=" ;
	Str0 = Str0 + Вв.Курс.Получить(ТекущаяДата());
* ...
	Сообщить("Документ " + Конт.Вид() + " № " + Конт.НомерДок
	+" от "+Конт.ДатаДок+" не проводится!!!");
  переделываем--- :
	Стр2 = "Документ " + Конт.Вид() + " № " + Строка(Конт.НомерДок) ;
	Стр2 = Стр2 + " от " + Строка(Конт.ДатаДок) + " не проводится!!!";
	Сообщить(Стр2);
* если в модуле встречается :
	НужнаяСтр = """ЗначениеСЗ555""" + ",";
  заменяем на:
	К = Симв(34); // двойные кавычки
	НужнаяСтр = К + "ЗначениеСЗ555" + К + ",";
  транслятору станет намного легче...
* Если в тексте для Таблицы Значений встречается:
	тз.ПолучитьПараметрыКолонки("КолЧисло",,ПеремДлина,ПеремТочн);
  нужно поставить:
	а = тз.ПолучитьПараметрыКолонки("КолЧисло",,ПеремДлина,ПеремТочн);
  Потому как там много необязательных параметров, которые передаются по ссылке... транслятор путается... :-(
* ...
	Если сз.НайтиЗначение("Значение444") = 2 тогда
  меняем на
	Рез = сз.НайтиЗначение("Значение444");
	Если Рез = 2 тогда
* ...
	тз.ВыбратьСтроку(ВыбСтр,"Выбор строки в таблице...");
  меняем на
	Рез = тз.ВыбратьСтроку(ВыбСтр,"Выбор строки в таблице...");

== Проверить
=== Python
* можно ли вставлять свои простые переменные в global
* можно ли импортировать модуль _не_ из файла

== Vocabulary
* aim == цель
* vocabulary == словарь
* ident == отступ
* strategic == Стратегическая
* tactic == Тактическая
* objects == Объекты
* global == Глобальные
* Form == Форма
* PreProcessing == подготовка исподников к трансляции
