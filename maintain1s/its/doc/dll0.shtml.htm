<html><head>
<title>Динамические библиотеки для начинающих</title>
<style>
pre {border: 1px solid; padding: 3px; width: 468px; overflow: auto; font-size: 9pt;}
</style>

<meta http-equiv="content-type" content="text/html; charset=Windows-1251">
</head>
<body bgcolor=#FFFFFF link=#006890 vlink=#003860 alink=#800000 text=#000000 topmargin="0" marginheight="0">

<h3>Динамические библиотеки для начинающих</h3>
(статья была опубликована в журнале &quot;Программист&quot;)

<p>В наше время Windows-разработчик шагу не может ступить без <b>динамических библиотек</b> (<b>D</b>ynamic&nbsp;<b>L</b>ink&nbsp;<b>L</b>ibrary - <b>DLL</b>); а перед начинающими программистами, желающими разобраться в предмете, встает масса вопросов:
<ol>
<ol>
<li>как эффективно использовать чужие DLL? </li>
<li>как создать свою собственную? </li>
<li>какие способы загрузки DLL существуют, и чем они отличаются? </li>
<li>как загружать ресурсы из DLL?</li>
</ol>
</ol>
<p>Обо всем этом (и многом другом) рассказывает настоящая глава. Материал рассчитан на пользователей<b> Microsoft&nbsp;Visual&nbsp;C++</b>, а поклонникам других языков и компиляторов придется разбираться с ключами компиляции приведенных примеров самостоятельно.
<h4>Создание собственной DLL</h4>
<p>С точки зрения программиста - DLL представляет собой библиотеку функций (ресурсов), которыми может пользоваться любой процесс, загрузивший эту библиотеку. Сама загрузка, кстати, отнимает время и увеличивает расход потребляемой приложением памяти; поэтому бездумное дробление одного приложения на множество DLL ничего хорошего не принесет.
<p>Другое дело - если какие-то функции используются несколькими приложениями. Тогда, поместив их в одну DLL, мы избавимся от дублирования кода и сократим общий объем приложений - и на диске, и в оперативной памяти. Можно выносить в DLL и редко используемые функции отдельного приложения; например, немногие пользователи текстового редактора используют в документах формулы и диаграммы - так зачем же соответствующим функциям впустую &quot;отъедать&quot; память?
<p>Загрузившему DLL процессу доступны не все ее функции, а лишь явно предоставляемые самой DLL для &quot;внешнего мира&quot; - т.&nbsp;н. <i><b>экспортируемые</b></i>. Функции, предназначенные сугубо для &quot;внутреннего&quot; пользования, экспортировать бессмысленно (хотя и не запрещено). Чем больше функций экспортирует DLL - тем медленнее она загружается; поэтому к проектированию <i><b>интерфейса</b></i> (способа взаимодействия DLL с вызывающим кодом) следует отнестись повнимательнее. Хороший интерфейс интуитивно понятен программисту, немногословен и элегантен: как говорится, ни добавить, ни отнять. Строгих рекомендаций на этот счет дать невозможно - умение приходит с опытом
<p>Для экспортирования функции из DLL - перед ее описанием следует указать ключевое слово <i><b>__declspec(dllexport)</b></i>, как показано в следующем примере:
<pre>

// myfirstdll.c
#include &lt;stdio.h&gt;

// Ключевое слово __declspec(dllexport)
// делает функцию экспортируемой
<b>__declspec(dllexport)</b> void Demo(char *str)
{
  // Выводим на экран переданную функции Demo строку
  printf(str);
}
</pre>
<p><b>Листинг 10 Демонстрация экспорта функции из DLL</b>
<p>Для компиляции этого примера в режиме командной строки можно запустить компилятор Microsoft&nbsp;Visual&nbsp;Studio: &quot;<i>cl.exe&nbsp;myfirstdll.c&nbsp;/LD</i>&quot;. Ключ &quot;/LD&quot; указывает линкеру, что требуется получить именно DLL.
<p>Для сборки DLL из интегрированной оболочки Microsoft&nbsp;Visual&nbsp;Studio - при создании нового проекта нужно выбрать пункт &quot;<i>Win32&nbsp;Dynamics&nbsp;Link&nbsp;Library</i>&quot;, затем &quot;<i>An&nbsp;Empty&nbsp;DLL&nbsp;project</i>&quot;; потом перейти к закладке &quot;<i>File&nbsp;View</i>&quot; окна &quot;<i>Workspace</i>&quot; - и, выбрав правой клавишей мыши папку &quot;<i>Source&nbsp;Files</i>&quot;, добавить в проект новый файл (&quot;<i>Add&nbsp;Files&nbsp;to&nbsp;Folder</i>&quot;). Компиляция осуществляется как обычно (&quot;Build&quot; ( &quot;Build&quot;).
<p>Если все прошло успешно - в текущей директории (или в директории Release\Debug при компиляции из оболочки) появится новый файл - &quot;MyFirstDLL.dll&quot;. Давайте заглянем в него через &quot;микроскоп&quot; - утилиту <b>dumpbin</b>, входящую в штатную поставку SDK и Microsoft&nbsp;Visual&nbsp;Studio: &quot;<i>dumpbin /EXPORTS MyFirstDLL.dll</i>&quot;. Ответ программы в несколько сокращенно виде должен выглядеть так:
<pre>
  Section contains the following exports for myfirst.dll
             0 characteristics
          0.00 version
             1 ordinal base
             1 number of functions
             1 number of names
<b>             1    0 00001000 Demo</b>
</pre>
<p>Получилось! Созданная нами DLL действительно экспортирует функцию &quot;Demo&quot; - остается только разобраться, как ее вызывать

<h4>Вызов функций из DLL</h4>
<p>Существует два способа загрузки DLL: с <i><b>явной </b></i>и <i><b>неявной компоновкой</b></i>.
<p>При<i>&nbsp;</i><i><b>неявной компоновке</b></i> функции загружаемой DLL добавляются в секцию импорта вызывающего файла. При запуске такого файла загрузчик операционной системы анализирует секцию импорта и подключает все указанные библиотеки. Ввиду своей простоты этот способ пользуется большой популярностью; но простота - простотой, а неявной компоновке присущи определенные недостатки и ограничения:
<ol>
<li>все подключенные DLL загружаются <i>всегда</i>, даже если в течение всего сеанса работы программа ни разу не обратится ни к одной из них;</li>
<li>если хотя бы одна из требуемых DLL отсутствует (или DLL не экспортирует хотя бы одной требуемой функции) - загрузка исполняемого файла прерывается сообщением &quot;<i>Dynamic&nbsp;link&nbsp;library  could&nbsp;not&nbsp;be&nbsp;found</i>&quot; (или что-то в этом роде) - даже если отсутствие этой DLL некритично для исполнения программы. Например, текстовой редактор мог бы вполне работать и в минимальной комплектации - без модуля печати, вывода таблиц, графиков, формул и прочих второстепенных компонентов, но если эти DLL загружаются неявной компоновкой - хочешь не хочешь, придется &quot;тянуть&quot; их за собой.</li>
<li>поиск DLL происходит в следующем порядке: в каталоге, содержащем вызывающий файл; в текущем каталоге процесса; в системном каталоге %Windows%System%; в основном каталоге %Windows%; в каталогах, указанных в переменной PATH. Задать другой путь поиска невозможно (вернее - возможно, но для этого потребуется вносить изменения в системный реестр, и эти изменения окажут влияние на все процессы, исполняющиеся в системе - что не есть хорошо).</li>
</ol>

<p><i><b>Явная компоновка </b></i>устраняет все эти недостатки - ценой некоторого усложнения кода. Программисту самому придется позаботиться о загрузке DLL и подключении экспортируемых функций (не забывая при этом о контроле над ошибками, иначе в один прекрасный момент дело кончится зависанием системы). Зато явная компоновка позволяет подгружать DLL по мере необходимости и дает программисту возможность самостоятельно обрабатывать ситуации с отсутствием DLL. Можно пойти и дальше - не задавать имя DLL в программе явно, а сканировать такой-то каталог на предмет наличия динамических библиотек и подключать все найденные к приложению. Именно так работает механизм поддержки plug-in’ов в популярном файл-менеджере FAR (да и не только в нем).
<p>Таким образом, <i>неявной компоновкой целесообразно пользоваться лишь для подключения загружаемых в каждом сеансе, жизненно необходимых для работы приложения динамических библиотек; во всех остальных случаях - предпочтительнее явная компоновка</i>.

<h4>Загрузка DLL с неявной компоновкой</h4>
<p>Чтобы вызвать функцию из DLL, ее необходимо объявить в вызывающем коде - либо как <i><b>external</b></i> (т.&nbsp;е. как обычную внешнюю функцию), либо предварить ключевым словом <i><b>__declspec(dllimport)</b></i>. Первый способ более популярен, но второй все же предпочтительнее - в этом случае компилятор, поняв, что функция вызывается именно из DLL, сможет соответствующим образом оптимизировать код. Например, функция &quot;Demo&quot; из созданной нами библиотеки - &quot;<i>MyFirstDll</i>&quot; вызывается так:
<pre>

  // ImplictDll.c
  // Объявляем внешнюю функцию Demo
  <b>__declspec(dllimport</b>) void Demo(char *str);

  main()
  {
    // Вызываем функцию Demo из DLL
    Demo(&quot;Hello, World!\n&quot;);
  }
</pre>
<p><b>Листинг 11 Демонстрация вызова функции из DLL неявной компоновкой</b>
<p>Из командной строки данный пример компилируется так: &quot;<i>cl.exe&nbsp;ImplictDll.c&nbsp;myfirstdll.lib</i>&quot;, где &quot;<i>myfirstdll.lib</i>&quot; - имя библиотеки, автоматически сформированной компоновщиком при создании нашей DLL.
<p>Разумеется, &quot;чужие&quot; DLL не всегда поставляются вместе с сопутствующими библиотеками, но их можно легко изготовить самостоятельно! На этот случай предусмотрена специальная утилита <i><b>implib</b></i>, поставляемая вместе с компилятором, и вызываемая так: &quot;<i>implib.exe&nbsp;Имя_файла _создаваемой_библиотеки&nbsp;Имя_DLL</i>&quot;. 
<p>В нашем случае - не будь у нас файла &quot;<i>MyFirstDLL.lib</i>&quot;, его пришлось бы получить так: &quot;<i>implib.exe&nbsp;MyFirstDLL.lib&nbsp;MyFirstDLL.dll</i>&quot;. Со всеми стандартными DLL, входящими в состав Windows, эту операцию проделывать не нужно, т.к. необходимые библиотеки распространяются вместе с самим компилятором.
<p>Для подключения библиотеки в интегрированной среде Microsoft&nbsp;Visual&nbsp;Studio - в меню &quot;<i>Project</i>&quot; выберите пункт &quot;<i>Project&nbsp;Settings</i>&quot;, в открывшемся диалоговом окне перейдите к закладке &quot;<i>Link</i>&quot; и допишите имя библиотеки в конец строки &quot;<i>Object/Library Modules</i>&quot;, отделив ее от остальных символом пробела.
<p>Если все прошло успешно, появится новый файл &quot;<i>ImplictDll.exe</i>&quot;, который, будучи запущенным, горделиво выведет на экран &quot;<i>Hello, Word!</i>&quot;. Это означает, что наша DLL подключена и успешно работает.
<p>Заглянем внутрь: как это происходит? Запустим &quot;<i>dumpbin&nbsp;/IMPORTS ImplictDll.exe&quot;</i> и<i>&nbsp;</i>посмотрим, что нам сообщит программа:
<pre>
  File Type: EXECUTABLE IMAGE

    Section contains the following imports:

      <b>myfirstdll.dll</b>
             404090 Import Address Table
             4044C8 Import Name Table
                  0 time date stamp
                  0 Index of first forwarder reference

<b>                0  Demo</b>

      KERNEL32.dll
             404000 Import Address Table
             404438 Import Name Table
                  0 time date stamp
                  0 Index of first forwarder reference

              19B  HeapCreate
              2BF  VirtualFree
               CA  GetCommandLineA
              174  GetVersion
               7D  ExitProcess
              29E  TerminateProcess
               F7  GetCurrentProcess
</pre>

<p>Вот она - &quot;<i>Myfirstdll.dll</i>&quot; (в тексте выделена жирным шрифтом), и вот функция &quot;<i>Demo</i>&quot;, а кроме нее - обнаруживает свое присутствие библиотека <i>KERNEL32.DLL&nbsp;</i>– она необходима RTL-коду (<i><b>R</b></i><i>un&nbsp;</i><i><b>T</b></i><i>ime&nbsp;</i><i><b>L</b></i><i>ibrary - библиотека времени исполнения</i>), насильно помещенному компилятором в наше приложение. RTL-код обеспечивает работу с динамической памятью (heap), считывает аргументы командной строки, проверяет версию Windows и многое-многое другое! Отсюда и появляются в таблице импорта функции <i>HeapCreate</i>, <i>GetCommandLine</i>, <i>GetVersion </i>и т.д. Так что - не удивляйтесь, увидев &quot;левый&quot; импорт в своем приложении!
<p>Проследить, как именно происходит загрузка DLL, можно с помощью отладчика. Общепризнанный лидер - это, конечно, SoftIce от NuMega, но для наших экспериментов вполне сойдет и штатный отладчик Microsoft&nbsp;Visual&nbsp;Studio. Откомпилировав нашу вызывающую программу, нажмем &lt;F10&gt; для пошагового прогона приложения
<p>Оппаньки! Не успело еще выполниться ни строчки кода, как в окне &quot;output&quot; отладчика появились следующие строки, свидетельствующие о загрузке внешних DLL: NTDLL.DLL, MyFirstDll.dll и Kernel32.dll. Так и должно быть - при неявной компоновке динамические библиотеки подключаются сразу же при загрузке файла, задолго до выполнения функции main!

<font size=-2><pre>
Loaded 'C:\WINNT\System32\ntdll.dll', no matching symbolic information found.
Loaded 'F:\ARTICLE\PRG\DLL.files\myfirstdll.dll', no matching symbolic information found.
Loaded 'C:\WINNT\system32\kernel32.dll', no matching symbolic information found.
</pre></font>

<h4>Загрузка DLL с явной компоновкой</h4>
<p>Явную загрузку динамических библиотек осуществляет функция HINSTANCE <b>LoadLibrary</b>(LPCTSTR lpLibFileName) или ее расширенный аналог HINSTANCE <b>LoadLibraryEx</b>(LPCTSTR lpLibFileName, HANDLE hFile, DWORD dwFlags).
<p>Обе они экспортируются из KERNEL32.DLL, следовательно, каждое приложение требует неявной компоновки по крайней мере этой библиотеки. В случае успешной загрузки DLL возвращается линейный адрес библиотеки в памяти. Передав его функции FARPROC <b>GetProcAddress</b>(HMODULE hModule, LPCSTR lpProcName) - мы получим указатель на функцию lpProcName, экспортируемую данной DLL. При возникновении ошибки обе функции возвращают NULL. После завершения работы с динамической библиотекой ее следует  освободить вызовом функции BOOL <b>FreeLibrary</b>(HMODULE hLibModule). Для пояснения приведем код примера с подробными комментариями:
<pre>

// DynCall.c
#include &lt;stdio.h&gt;
#include &lt;windows.h&gt;

main()
{
  // Дескриптор загружаемой dll
  HINSTANCE h;

  // Объявление указателя на функцию, вызываемой из DLL
  // Обратите внимание – имена объявляемой функции и
  // функции, вызываемой из DLL, могут и не совпадать,
  // т.к. за выбор вызываемой функции отвечает
  // GetProcAddress
  void (*DllFunc) (char *str);

  // Загружаем MyFirstDLL
  h=LoadLibrary(&quot;MyFirstDLL.dll&quot;);

  // Контроль ошибок – если загрузка прошла успешно,
  // функция вернет что-то отличное от нуля
  if (!h)
  {
    printf(&quot;Ошибка - не могу найти MyFirstDLL.dll\n&quot;);
    return;
  }

  // Вызовом GetProcAddress получаем адрес функции Demo
  // и присваиваем его указателю DllFunc с явным 
  // приведением типов. Это необходимо т.к.
  // GetProcAddress возвращает бестиповой far-указатель
  DllFunc=(void (*) (char *str))
            GetProcAddress(h,&quot;Demo&quot;);

  // Контроль ошибок – если вызов функции GetProcAddress
  // завершился успешно, она вернет ненулевой указатель
  if (!DllFunc)
  {
    printf(&quot;Ошибка! В MyFirstDLL &quot;
           &quot;отсутствует ф-ция   Demo\n&quot;);
    return;
  }

  // Вызов функции Demo из DLL
  DllFunc(&quot;Test&quot;);

  // Выгрузка динамической библиотеки из памяти
  FreeLibrary(h);
}
</pre>
<p><b>Листинг 12 Демонстрация вызова функции из DLL явной компоновкой</b>
<p>Компилировать так: &quot;<i>cl&nbsp;DynCall.c</i>&quot; - никаких дополнительных библиотек указывать не нужно (необходимые <i>kernel32.lib</i> и <i>LIBC.lib</i> компоновщик подключит самостоятельно).
<p>В интегрированной среде Microsoft&nbsp;Visual&nbsp;Studio достаточно щелкнуть мышкой по иконке &quot;<i>Build</i>&quot; - и никаких дополнительных настроек!
<p>Для изучения секции импорта только что полученного файла запустим утилиту <i>Dumpbin&nbsp;</i>– обратите внимание, что здесь отсутствует всякое упоминание о MyFirstDLL.dll, но обнаруживаются две функции: LoadLibrary и GetProcAddress - которые и загружают нашу библиотеку. Это очень важное обстоятельство - <i>изучение секции импорта исследуемого файла не всегда позволяет установить полный перечень функций и динамических библиотек, которые использует приложение</i>. Наличие LoadLibrary и GetProcAddress красноречиво свидетельствует о том, что приложение подгружает какие-то модули во время работы самостоятельно.
<p>Чтобы выяснить какие - запустим его под отладчиком. Сразу же после загрузки исполняемого файла в окне Output появятся строки:

<font size=-2><pre>
Loaded 'C:\WINNT\System32\ntdll.dll', no matching symbolic information found.
Loaded 'C:\WINNT\system32\kernel32.dll', no matching symbolic information found.
</pre></font>

<p>Это опять грузятся обязательные KERNEL32.DLL и NTDLL.DLL (последнее - только под Windows NT/2000). Никакого упоминания о MyFirstDLL.dll еще нет. Пошагово исполняя программу (&quot;<i>Debug</i>&quot; ( &quot;<i>Step&nbsp;Over</i>&quot;), дождемся выполнения функции LoadLibrary. Тут же в Output-окне появится следующая строка:

<font size=-2><pre>
Loaded 'F:\ARTICLE\PRG\DLL.files\myfirstdll.dll', no matching symbolic information found.
</pre></font>

<p>Наша динамическая библиотека загрузилась; но не сразу после запуска файла (как это происходило при неявной компоновке), а только когда в ней возникла необходимость!
<p>Если же по каким-то причинам DLL не найдется, или окажется, что в ней отсутствует функция Demo - операционная система не станет &quot;убивать&quot; приложение с &quot;некрологом&quot; критической ошибки, а предоставит программисту возможность действовать самостоятельно. В качестве эксперимента попробуйте удалить (переименовать) MyFirstDLL.dll и посмотрите, что из этого получится.

<h4>Выгрузка динамических библиотек из памяти</h4>
<p>Когда загруженная динамическая библиотека больше не нужна - ее можно освободить, вызвав функцию <i>BOOL </i><i><b>FreeLibrary</b></i><i>(HMODULE hLibModule) и </i>передав ей дескриптор библиотеки, ранее возвращенный функцией LoadLibrary. Обратите внимание - DLL можно именно <i><b>освободить</b></i>, но <i><b>не выгрузить</b></i>! Выгрузка DLL из памяти <i><b>не гарантируется</b></i>, даже если работу с ней завершили все ранее загрузившие ее процессы.
<p>Задержка выгрузки предусмотрена специально - на тот случай, если эта же DLL через некоторое время вновь понадобится какому-то процессу. Такой трюк оптимизирует работу часто используемых динамических библиотек, но плохо подходит для редко используемых DLL, загружаемых лишь однажды на короткое время. Никаких документированных способов насильно выгрузить динамическую библиотеку из памяти нет; а те, что есть - работают с ядром на низком уровне и не могут похвастаться переносимостью. Поэтому здесь мы их рассматривать не будем. К тому же - тактика освобождения и выгрузки DLL по-разному реализована в каждой версии Windows: Microsoft, стремясь подобрать наилучшую стратегию, непрерывно изменяет этот алгоритм; а потому и отказывается его документировать.
<p>Нельзя не обратить внимания на одно очень важное обстоятельство: <i>динамическая библиотека не владеет никакими ресурсами - ими владеет, независимо от способа компоновки, загрузивший ее процесс</i>. Динамическая библиотека может открывать файлы, выделять память и т.&nbsp;д., но память не будет автоматически освобождена после вызова FreeLibrary, а файлы не окажутся сами собой закрыты - все это произойдет лишь после завершения процесса, но не раньше! Естественно, если программист сам не освободит все ненужные ресурсы вручную, с помощью функций CloseHandle, FreeMemory и подобных им.
<p>Если функция FreeLibrary пропущена, DLL освобождается (но не факт, что выгружается!) только после завершения вызвавшего процесса. Могут возникнуть сомнения: раз FreeLibrary немедленно не выгружает динамическую библиотеку из памяти, так зачем она вообще нужна? Не лучше ли тогда все пустить на самотек - все равно ведь загруженные DLL будут гарантированно освобождены после завершения процесса? Что ж, доля правды тут есть, и автор сам порой так и поступает; но при недостатке памяти операционная система может беспрепятственно использовать место, занятое освобожденными динамическими библиотеками под что-то полезное - а если DLL еще не освобождены, их придется &quot;скидывать&quot; в файл подкачки, теряя драгоценное время. Поэтому лучше освобождайте DLL сразу же после их использования!

<h4>ООП и DLL</h4>
<p>Динамические библиотеки ничего не знают ни о каком ООП! Они не имеют ни малейшего представления о существовании классов! Все, что умеют DLL - экспортировать одно или несколько имен функций (ресурсов, глобальных переменных), а уж как его использовать - решать программисту или компилятору.
<p>Что ж; испытаем компилятор на &quot;сообразительность&quot;, включив в описание класса ключевое слово <i><b>__declspec(dllexport)&nbsp;</b></i><i>–</i> и посмотрим, что из этого выйдет:
<pre>

  // DLLclass.cpp
  #include &lt;stdio.h&gt;

  class <i><b>__declspec(dllexport)</b></i> MyDllClass{
  public:
    Demo(char *str);
  };

  MyDllClass::Demo(char *str)
  {
    printf(str);
  }
</pre>
<p><b>Листинг 13 Демонстрация экспорта класса из DLL</b>

<p>Откомпилируем этот код как обычную DLL и заглянем в таблицу импорта утилитой dumpbin:

<pre>
dumpbin /EXPORTS DLLclass.dll 

File Type: DLL
 Section contains the following exports for DLLclass.dll
          0 characteristics
   3B1B98E6 time date stamp Mon Jun 04 18:19:18 2001
       0.00 version
          1 ordinal base
          2 number of functions
          2 number of names
   ordinal hint RVA      name

<b>         1    0 00001000 ??4MyDllClass@@QAEAAV0@ABV0@@Z</b>
<b>         2    1 00001020 ?Demo@MyDllClass@@QAEHPAD@Z</b>
</pre>
<p>Таблица импорта явно не пуста - но выглядит странно. Компилятор искалечил имена, чтобы втиснуть в них информацию о классах и аргументах функций без нарушений жестких ограничений, налагаемых стандартом на символы, допустимые в экспортируемых именах (например, запрещается использовать знак двоеточие, скобка и т.&nbsp;д.).
<p>Как же со всем этим работать? Попробуй-ка угадай - во что превратится то или иное имя после компиляции! Впрочем, при неявной компоновке ни о чем гадать не придется, т.&nbsp;к. обо всем позаботится сам компилятор, а от программиста потребуется лишь описать класс, предварив его ключевым словом <i><b>__declspec(dllimport)</b></i>:
<pre>

  // DLLClassCall.cpp
  #include &lt;stdio.h&gt;

  class <b>__declspec(dllimport) </b>MyDllClass{
  public:
    Demo(char *str);
  };

  main()
  {
    MyDllClass zzz;
    zzz.Demo(&quot;Привет, ООП! А мы тут!&quot;);
  }
</pre>
<p><b>Листинг 14 Демонстрация импорта класса из DLL неявной компоновкой</b>
<p>Откомпилируйте пример как обычную программу с неявной компоновкой (&quot;<i>cl&nbsp;DLLClassCall.cpp&nbsp;DLLClass.lib</i>&quot;) и попробуйте запустить полученный файл. Работает? Никакой разницы с &quot;классическим&quot; Си нет, не правда ли? Вот только как подключить DLL с явной компоновкой? Неужели нельзя запретить компилятору &quot;калечить&quot; имена функций?!  Конечно же, можно

<h4>Мангл и как его побороть или импорт классов из DLL явной компоновкой</h4>
<p>Искажение функций Cи&nbsp;++ компилятором называется по-английски &quot;<i><b>mangle</b></i>&quot;, и среди русскоязычных программистов широко распространена его калька - &quot;манглить&quot;. В принципе &quot;манглеж&quot; функций не препятствует их явному вызову посредством GetProcAddress - достаточно лишь знать, как точно называется та или иная функция, что нетрудно выяснить тем же dumpbin. Однако засорение программы подобными &quot;заученными&quot; именами выглядит не очень-то красиво; к тому же - всякий компилятор &quot;манглит&quot; имена по-своему, и непосредственное использование имен приводит к непереносимости программы.
<p>Существует способ обойти искажение имен - для этого необходимо подключить к линкеру специальный DEF-файл, перечисляющий имена, которые не должны измениться. В нашем случае он должен выглядеть так 
<pre>

  // DllClass.def:
<b>  EXPORTS</b>
    Demo
</pre>
<p><b>Листинг 15 Отказ от &quot;замангления&quot; имен</b>
<p>Сперва идет ключевое слово &quot;EXPORTS&quot;, за которым следуют одно или несколько &quot;неприкасаемых&quot; имен. Каждое имя начинается с новой строки, и в его конце <b>не</b> указывается точка с запятой.
<p>Для подключения DEF-файла при компиляции из командной строки - используйте опцию &quot;<i>/link&nbsp;/DEF:имя_файла.def</i>&quot;, например так: &quot;<i>cl&nbsp;DLLclass.cpp&nbsp;/LD&nbsp;/link&nbsp;/DEF:DLLClass.def</i>&quot;.
<p>Для подключения DEF-файла в интегрированной среде Microsoft&nbsp;Visual&nbsp;Studio - перейдите к закладке &quot;<i>File&nbsp;View</i>&quot; окна &quot;<i>Workspace</i>&quot; и, щелкнув правой клавишей по папке &quot;<i>Source&nbsp;Files</i>&quot;, выберите в контекстом меню пункт &quot;<i>Add&nbsp;Files&nbsp;to&nbsp;Folder</i>&quot;, а затем укажите путь к DEF-файлу. Откомпилируйте проект как обычно: &quot;Build&quot; ( &quot;Build&quot;.
<p>Заглянув в таблицу импорта полученного DLL-файла, мы, среди прочей информации, увидим следующее:

<pre>
  1    0 00001000 ??4MyDllClass@@QAEAAV0@ABV0@@Z
<b>  2    1 00001020 Demo</b>
</pre>

<p>Теперь имя функции Demo выглядит &quot;как положено&quot;. А абракадабра, расположенная строчкой выше - это конструктор класса MyDllClass, который, хоть и не был специально объявлен, все равно экспортируется из динамической библиотеки.
<p>Однако, избавившись от одной проблемы, мы получаем другую - имя функции Demo потеряло всякое представление о классе, которому оно принадлежало; и теперь придется загружать его вручную, повторяя эту операцию для каждого элемента класса. Фактически - придется в вызываемой программе собирать &quot;скелет&quot; класса из &quot;косточек&quot; заново. Но иного способа явной загрузки класса из DLL не существует.
<p>Следующий пример демонстрирует вызов функции <i>MyDllClass</i> из динамической библиотеки с явной компоновкой. Обработка ошибок для упрощения опущена. Обратите внимание, как объявляется функция Demo - описания класса в DLL и в вызывающей программе существенно отличаются, поэтому с идеей поместить описания класса в общий для всех include-файл придется расстаться.
<pre>

  // DeMangle.cpp
  #include &lt;windows.h&gt;

  class MyDllClass{
  public:
    void (*Demo) (char *str);
  };

  main()
  {
    HINSTANCE h=LoadLibrary(&quot;DllClass.dll&quot;);
    MyDllClass zzz;

    // Внимание! Выполнение конструктора / деструктора
    // класса при явной загрузке не происходит
    // автоматически и при необходимости эту операцию
    // следует выполнить вручную
    zzz.Demo=(void (*) (char *str))
               GetProcAddress(h,&quot;Demo&quot;);
    zzz.Demo(&quot;Test&quot;);
  }
</pre>
<p><b>Листинг 16 Демонстрация вызова функции MyDllCLass::Demo явной компоновкой</b>

<h4>Загрузка ресурсов из DLL</h4>
<p>Помимо функций, динамические библиотеки могут содержать и ресурсы - строки, иконки, рисунки, диалоги и т.&nbsp;д. Хранение ресурсов в DLL очень удобно; в частности - при создании приложений с многоязычным интерфейсом: заменив одну DLL на другую, мы заменяем все надписи в программе, скажем, с английского на русский - и, заметьте, без всяких &quot;хирургических вмешательств&quot; в код приложения! Аналогично можно менять иконки, внешний вид диалогов и т.&nbsp;д.
<p>Создание DLL, содержащей ресурсы, ничем не отличается от создания исполняемого приложения с ресурсами; сначала необходимо создать сам файл ресурсов - например, так:
<pre>

  // MyResDll.rc
  #pragma code_page(1251)

  STRINGTABLE DISCARDABLE 
  BEGIN
      1             &quot;Hello, World!&quot;
  END
</pre>
<p><b>Листинг 17 Создание DLL, содержащей одни лишь ресурсы</b>
<p>Файл ресурсов надо скомпилировать - &quot;<i>rc&nbsp;MyResDll.rc</i>&quot; - и преобразовать линкером в DLL, обязательно указав флаг &quot;<i>/NOENTRY</i>&quot;, т.&nbsp;к. эта динамическая библиотека содержит исключительно одни ресурсы и ни строки кода: &quot;<i>link&nbsp;MyRedDll.res&nbsp;/DLL&nbsp;/NOENTRY</i>&quot;.
<p>В Visual&nbsp;Studio это сделать еще проще - достаточно кликнуть по папке &quot;<i>Resourses</i>&quot; окна &quot;<i>File&nbsp;View</i>&quot; и добавить новый файл ресурса, который затем можно будет модифицировать визуальным редактором по своему усмотрению.
<p>Для загрузки ресурса из DLL - в принципе, можно воспользоваться уже знакомой нам функцией LoadLibray, и передавать возращенный ею дескриптор LoadString или другой функции, работающей с ресурсами. Однако загрузку динамической библиотеки можно значительно ускорить, если &quot;объяснить&quot; системе, что эта DLL не содержит ничего, кроме ресурсов, и нам достаточно лишь спроецировать ее на адресное пространство процесса, а обо всем остальном мы сумеем позаботиться и самостоятельно.
<p>Вот тут-то и пригодится функция LoadLibraryEx: ее первый аргумент, как и у коллеги LoadLibrary, задает имя динамической библиотеки для загрузки, второй - зарезервирован и должен быть равен нулю, а третий, будучи равным <i><b>LOAD_LIBRARY_AS_DATAFILE,</b></i> заставляет функцию делать именно то, что нам нужно - загружать DLL как базу данных (если динамическая библиотека содержит помимо ресурсов еще и код, то загрузка с этим ключом проходит все равно успешно, но функции загруженной DLL не будут доступны - только ресурсы):
<pre>

  // DllLoadRes.c
  #include &lt;stdio.h&gt;
  #include &lt;windows.h&gt;

  main()
  {
    HINSTANCE h;
    char buf[100];
    h=LoadLibraryEx(&quot;MyResDll.dll&quot;,0,
        LOAD_LIBRARY_AS_DATAFILE);

    LoadString(h,1,&amp;buf[0],99);
    printf(&quot;%s\n&quot;,&amp;buf[0]);
  }
</pre>
<p><b>Листинг 18 Демонстрация оптимизированной загрузки DLL, не содержащей ничего кроме ресурсов</b>
<p>Эта программа компилируются точно так же, как и предыдущие примеры явной компоновки - и после запуска победно выводит на экране &quot;<i>Hello, Word!</i>&quot;, подтверждая, что ресурс &quot;строка&quot; из динамической библиотеки был успешно загружен! Аналогичным способом можно загружать ресурсы из исполняемых файлов; с этой точки зрения они ничем не отличаются от динамических библиотек.
</body>
</html>
