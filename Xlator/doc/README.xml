<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN" "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">

<article lang="en">
<articleinfo>
    <title>Xlating 1C:Basic into Python</title>
    <date>11 July 2006</date>
    <author>
        <firstname>Eugene</firstname>
        <othername>A.</othername>
        <surname>Pivnev</surname>
        <affiliation><address><email>ti.eugene@gmail.com</email></address></affiliation>
    </author>
    <authorinitials>EAP</authorinitials>

<revhistory><revision><revnumber>0.1</revnumber><date>11 July 2006</date><authorinitials>EAP</authorinitials></revision></revhistory>

</articleinfo>
<section>
<title>Aims</title>
<section>
<title>Strategy</title>
<simpara>Make Python as 1L working language (one from !)</simpara>

</section>
<section>
<title>Tactic</title>
<simpara>Convert 1C:Basic texts into Python scripts (причем, ближе в Python).</simpara>

</section>
</section>
<section>
<title>Objects</title>
<itemizedlist>
<listitem>
<simpara>
Global:
  &#8212; Module
  &#8212; Tables
</simpara>
<orderedlist>
<listitem>
<simpara>
Calculated cells
</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>
Objects <footnote><simpara>Объект (Документ, Расчет)</simpara></footnote>:
  &#8212; Module
</simpara>
</listitem>
<listitem>
<simpara>
Form
  &#8212; Module
  &#8212; Dialog
</simpara>
<orderedlist>
<listitem>
<simpara>
Calculated fields
  &#8212; Tables
</simpara>
</listitem>
<listitem>
<simpara>
Calculated fields
</simpara>
</listitem>
</orderedlist>
</listitem>
</itemizedlist>
</section>
<section>
<title>PreProcessing</title>
<simpara>&#8230;</simpara>

</section>
<section>
<title>Translation</title>
<section>
<title>Legend <footnote><simpara>Условные обозначения</simpara></footnote></title>
<itemizedlist>
<listitem>
<simpara>
E  == English (с сохранением регистра)
</simpara>
</listitem>
<listitem>
<simpara>
R  == Russian (с сохранением регистра)
</simpara>
</listitem>
<listitem>
<simpara>
LE == Little only English
</simpara>
</listitem>
<listitem>
<simpara>
LR == Little only Russian
</simpara>
</listitem>
<listitem>
<simpara>
S  == Source
</simpara>
</listitem>
<listitem>
<simpara>
C  == Converted
</simpara>
</listitem>
</itemizedlist>
</section>
<section>
<title>Input (Вход) - для:</title>
<itemizedlist>
<listitem>
<simpara>
Глобальные
    &#8212; Модуль
    &#8212; Таблица
</simpara>
</listitem>
<listitem>
<simpara>
Модуль объекта
</simpara>
</listitem>
<listitem>
<simpara>
Форма
    &#8212; Модуль
</simpara>
<orderedlist>
<listitem>
<simpara>
словари:
</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>
Системные:
          &#8212; переменные (E, R)
          &#8212; методы (E, R)
</simpara>
</listitem>
<listitem>
<simpara>
глобальные (объявленные Экспорт):
          &#8212; переменные (S, C)
          &#8212; методы (S, C)
</simpara>
</listitem>
<listitem>
<simpara>
модуль:
          &#8212; переменные (S, C)
          &#8212; методы (S, C)
          &#8212; предопределенные (S, C)
</simpara>
</listitem>
<listitem>
<simpara>
формы:
          &#8212; поля (name (S, C), synonym (S, C))
</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</listitem>
</itemizedlist>
</section>
<section>
<title>1C syntax</title>
<simpara>(TODO: Move to translation)
  <emphasis role="strong"> Operators:
    ~метка:Оператор[(параметры)] ДобКлючевоеСлово;
  </emphasis> Module structure:
    <emphasis role="strong"> Variables definition
    </emphasis> Function/procedures
    <emphasis role="strong"> main program
  </emphasis> Special symbols:
        //      начинается комментарий. Комментарием считается весь текст от знака "//" до конца текущей строки.
        |       начале строки используется только в строковых константах и означает, что данная строка является продолжением предыдущей (перенос строки), (см. "Строковые константы").
        ~       начинается метка оператора.
        :       заканчивается метка оператора.
        ;       символ разделения операторов.
        ( )     список параметров методов, процедур и функций.
        [ ]     размерность массивов.
        ,       разделяет параметры в списке параметров методов, процедур и функций.
        " "     заключаются строковые константы.
        <emphasis> </emphasis>     заключаются константы даты.
        .       Десятичная точка в числовых константах. Разделитель, используемый в описаниях агрегатных типов данных.
        +       операцию сложения.
        -       операцию вычитания.
        <emphasis role="strong">       операцию умножения.
        /       операцию деления.
        %       остаток от деления
        &gt;       логическую операцию "больше".
        &gt;=      Логическая операция "больше или равно".
        &lt;       логическую операцию "меньше".
        &lt;=      Логическая операция "меньше или равно".
        =       присвоение или логическую операцию "равно".
        &lt;&gt;      логическую операцию "не равно".
  </emphasis> объявление переменной:
    var &lt;name&gt;<anchor id="size" xreflabel="[size]"/> [Export]
  <emphasis role="strong"> Процедура:
        Procedure &lt;name&gt;(<anchor id="Val] &lt;arg1&gt;[=&lt;defval&gt;]" xreflabel="&#8230;"/>) [Export]
        //Объявления локальных переменных;
        //Операторы;
        &#8230;
        [Return;]
        //Операторы;
        &#8230;
        EndProcedure
or
        Procedure &lt;name&gt;(<anchor id="Val] &lt;arg1&gt;[=&lt;defval&gt;]" xreflabel="&#8230;"/>) Forward
  </emphasis> число
  <emphasis role="strong"> дата
        <emphasis>ДД.ММ.ГГ</emphasis> или <emphasis>ДД.ММ.ГГГГ</emphasis>
  </emphasis> строки:
    <emphasis role="strong"> однострочные:
        "&#8230;"
    </emphasis> многострочные-1 (В данном случае между фрагментами, представляющими отдельные строки многострочной константы, не должно встречаться никаких символов, за исключением пробелов, переводов строки и строк комментариев.)
        Стр = "Первая строка"    // пример строковой константы
        "Вторая строка"
        "Третья строка";
    * многострочные-2 (В данном примере значение константы полностью идентично предыдущему примеру. Отличие заключается в том, что каждая отдельная составляющая не замыкается кавычками, а на каждой последующей строке помещен символ переноса строки "|". В этом варианте комментарии между открывающей и закрывающей кавычками не допускаются.)
        Стр = "Первая строка
        |Вторая строка
        |Третья строка";</simpara>

</section>
<section>
<title>Algorythm</title>
<orderedlist>
<listitem>
<simpara>
lexical analizer (лексический анализатор) - разбиение на токены
</simpara>
</listitem>
<listitem>
<simpara>
syntactic analyzer синтаксический анализатор) - построение синтаксического дерева
</simpara>
</listitem>
<listitem>
<simpara>
semantic analizer (семантический анализ) - &#8230;
</simpara>
</listitem>
<listitem>
<simpara>
codegeneration (кодогенерация) - генерация исходника на Python (русские наименования приведены в kw.txt):
</simpara>
<itemizedlist>
<listitem>
<simpara>
конструкции языка:
    &#8212; Comments
</simpara>
<variablelist>
<varlistentry>
<term>
1C
</term>
<listitem>
<simpara>
        // &#8230; (и до конца строки)
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Python
</term>
<listitem>
<simpara>
        # &#8230;
    &#8212; окончание оператора
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
1C
</term>
<listitem>
<simpara>
        ;
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Python
</term>
<listitem>
<simpara>
        \r ? ;
    &#8212; Date constants (константы даты)
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
1C
</term>
<listitem>
<simpara>
        <emphasis>DD.MM.YY[YY]</emphasis>
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Python
</term>
<listitem>
<simpara>
        Date(<emphasis>DD.MM.YY[YY]</emphasis>)
    &#8212; variable declaration (объявления переменных)
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
1C
</term>
<listitem>
<simpara>
        Var[ Export] &lt;name&gt;)
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Python
</term>
<listitem>
<simpara>
        &lt;var&gt; = None
    &#8212; Procedure/Function declaration (объявления процедур)
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
1C
</term>
<listitem>
<simpara>
        Procedure[ Export] &lt;name&gt; &#8230; EndProcedure
        Function[ Export] &lt;name&gt; &#8230; EndFunction
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Python
</term>
<listitem>
<simpara>
        def &#8230;
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
1C
</term>
<listitem>
<simpara>
        Procedure[ Export] Forward
        Function[ Export] Forward
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Python
</term>
<listitem>
<simpara>
        def
    &#8212; объявления функций (Функция|Function[ Export]..return..EndFunction) =&gt; def..return
</simpara>
</listitem>
</varlistentry>
</variablelist>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>
передача параметров по сцылке =&gt; semiauto (полуавтоматическая обработка) - см. PostProcessing
</simpara>
</listitem>
<listitem>
<simpara>
передача параметров по значению (Val(&lt;name&gt;)) =&gt; &lt;name&gt;
    &#8212; зарезервированные слова (reserved.txt) - .. (make special table)
</simpara>
<variablelist>
<varlistentry>
<term>
1C
</term>
<term>
Python
</term>
<listitem>
<simpara>
    &#8212; основная программа модулю =&gt; спецфункция - типа _init; только проследить, чтобы:
</simpara>
</listitem>
</varlistentry>
</variablelist>
</listitem>
<listitem>
<simpara>
не было пересечений
</simpara>
</listitem>
<listitem>
<simpara>
вызывалась после загрузки модуля
    &#8212; Условия (if..then..elseif..else..endif) =&gt; if..elif..else
</simpara>
<variablelist>
<varlistentry>
<term>
1C
</term>
<term>
Python
</term>
<listitem>
<simpara>
    &#8212; Цикл:
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
1C
</term>
<term>
Python
</term>
<listitem>
<simpara>
</simpara>
</listitem>
</varlistentry>
</variablelist>
</listitem>
<listitem>
<simpara>
for a=b to c do&#8230;enddo =&gt; for a in xrange(..)
</simpara>
</listitem>
<listitem>
<simpara>
while..do&#8230;enddo =&gt; while
</simpara>
</listitem>
<listitem>
<simpara>
continue =&gt; continue
</simpara>
</listitem>
<listitem>
<simpara>
break =&gt; break
    &#8212; Try..Except..EndTry =&gt; try..except..
</simpara>
<variablelist>
<varlistentry>
<term>
1C
</term>
<term>
Python
</term>
<listitem>
<simpara>
    &#8212; Label (Метка):
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
1C
</term>
<term>
Python
</term>
<listitem>
<simpara>
</simpara>
</listitem>
</varlistentry>
</variablelist>
</listitem>
<listitem>
<simpara>
Definition (объявление): ~&lt;name&gt; =&gt; handle processing (ручная обработка)
</simpara>
</listitem>
<listitem>
<simpara>
Call (Вызов): Goto &lt;mark&gt; =&gt; handle processing (ручная обработка)
    &#8212; Special:
</simpara>
</listitem>
<listitem>
<simpara>
#ЗагрузитьИзФайла =&gt; ?import?
</simpara>
<itemizedlist>
<listitem>
<simpara>
indents (отступы)
</simpara>
<variablelist>
<varlistentry>
<term>
1C
</term>
<term>
Python
</term>
<listitem>
<simpara>
    &#8212; в соответствии с конструкциями языка; 1 x &lt;tab&gt;/identотступ
</simpara>
</listitem>
</varlistentry>
</variablelist>
</listitem>
<listitem>
<simpara>
members:
    &#8212; Naming
</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>
E (English) =&gt; e_&lt;as_is&gt;
</simpara>
</listitem>
<listitem>
<simpara>
R (Russian) =&gt; r_&lt;translit&gt;
    &#8212; System:
</simpara>
</listitem>
<listitem>
<simpara>
variables/objects =&gt; E
</simpara>
</listitem>
<listitem>
<simpara>
methods =&gt; E
    &#8212; global ($GLOBAL == (e.g.) Global):
</simpara>
</listitem>
<listitem>
<simpara>
variable &lt;name&gt; =&gt; GLOBAL.&lt;name&gt;
</simpara>
</listitem>
<listitem>
<simpara>
method &lt;name&gt;:
</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>
predefined =&gt; E
</simpara>
</listitem>
<listitem>
<simpara>
userdefined =&gt;
</simpara>
<itemizedlist>
<listitem>
<simpara>
E =&gt; e_LE
</simpara>
</listitem>
<listitem>
<simpara>
R =&gt; translit =&gt; r_LE)
</simpara>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>
yet another thoughts (всякие мысли):
</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>
область переменных - надо как-то обрабатывать
</simpara>
</listitem>
<listitem>
<simpara>
Var &lt;name&gt; Export =&gt; &#8230;
</simpara>
<itemizedlist>
<listitem>
<simpara>
Global.register("a") |
</simpara>
</listitem>
<listitem>
<simpara>
a = None | &#8230;
</simpara>
</listitem>
<listitem>
<simpara>
global.__dict__["a"] = None
</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>
Var a =&gt; &#8230;
</simpara>
</listitem>
<listitem>
<simpara>
functions/procedures - need 2 B split&#8230;
</simpara>
<itemizedlist>
<listitem>
<simpara>
definition
</simpara>
</listitem>
<listitem>
<simpara>
member's call: lvalue/rvalue x var/func x std/global/userdef
    &#8212; Module:
</simpara>
</listitem>
<listitem>
<simpara>
variables
</simpara>
</listitem>
<listitem>
<simpara>
methods:
</simpara>
</listitem>
<listitem>
<simpara>
predefined =&gt; E
</simpara>
</listitem>
<listitem>
<simpara>
userdefeined =&gt; r|e_LE
    &#8212; Forms:
</simpara>
</listitem>
<listitem>
<simpara>
fields =&gt; Form.&lt;f_LE&gt;.Value
</simpara>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
<section>
<title>Output (Выход) - во что (физически) превращаются</title>
<itemizedlist>
<listitem>
<simpara>
Global
    &#8212; Module
    &#8212; Table fields
</simpara>
</listitem>
<listitem>
<simpara>
Objects (Documents, Обработка):
    &#8212; Module
</simpara>
</listitem>
<listitem>
<simpara>
Form
    &#8212; Module
</simpara>
<orderedlist>
<listitem>
<simpara>
System:
</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>
variables/objects
</simpara>
</listitem>
<listitem>
<simpara>
methods
</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>
Global
</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>
variables/objects
</simpara>
</listitem>
<listitem>
<simpara>
methods
</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>
This module
</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>
variables/objects
</simpara>
</listitem>
<listitem>
<simpara>
methods
</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>
Dialog
</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>
Calculated fields
</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>
Table
</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>
Calculated fields
</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</listitem>
</itemizedlist>
</section>
</section>
<section>
<title>Running (Исполнение)</title>
<section>
<title>Common (Общий порядок)</title>
<orderedlist>
<listitem>
<simpara>
Analize (анализ)
</simpara>
</listitem>
<listitem>
<simpara>
split on funcs (разбиение на функции)
</simpara>
</listitem>
<listitem>
<simpara>
compile each (компиляция каждой ф-ции отдельно в байт-код)
</simpara>
</listitem>
<listitem>
<simpara>
insert into *.__dict__ (подстаовка вызовов ф-ций в нужный словарь)
=== Features (Особенности)
</simpara>
<itemizedlist>
<listitem>
<simpara>
системные =&gt; глобальный контекст (from lw&#8230; import *)
</simpara>
</listitem>
<listitem>
<simpara>
глобальные =&gt; глобальный контекст (?)
</simpara>
</listitem>
<listitem>
<simpara>
поля формы
</simpara>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
</section>
</section>
<section>
<title>Features (Особенности)</title>
<simpara>Differences between 1C:Basic &amp; Python:
  <emphasis role="strong"> Порядок обхода контекста:
    </emphasis> 1C - глобальный, глобальный модуля, локальный ф-ции &lt;&gt; поля
    <emphasis role="strong"> Python - &#8230;
  </emphasis> &#8230;</simpara>

</section>
<section>
<title>Notes</title>
<section>
<title>Василий Здановский 6322</title>
<simpara>Тебе только надо распределить ИМЕНА переменных по трем пространствам
(EAP: еще бы вызвать их правильно&#8230;)
Модуль формы, сам объект (в 8-ке ЭтотОбъект), РеквизитыФормы, Сама морда непосредственно.
Причем в 77 есть последовательность обхода, в 8-ке все вааще явно указывается.
Делаешь в модуле формы соотв. ассоц. массивы + массивы методов и сводишь все к вызовам, которые я тебе описал.
В методах все аналогично, только массив модуля копируется и переменные маскируются.
Для получения списка имен пропиши: isName - возвращает может ли данное сочетание символов быть именем, isFuncColl - функцией, isFieldName - полем объекта, isMethodCall - вызов метода. Функции маленькие, поскольку базируются на первых двух. Дальше -проход по тексту модуля и создание списка методов и переменных модуля, потом проход по каждой функции. В итоге, можно свести весь текст модуля к выражениям на питоне с разруливанием по именам.
Это не сложно.
Я не описал глобальный модуль. Но, он компилится так же.  И маскируется массивом переменных модуля так же, как и в сл. разбора методов.
Еще раз повторяю - я просто обещал. Чуть позже сброшу
Но пока проект не завершен. Не могу. Просто не хочу рисковать.
А именно этот парсер в нем и прописан. Клиент хотел, чтобы уникальность кода, который для него прописывается, была соблюдена.
Если не дай Бог это выплывет - мне хоть в петлю лезь. Потому как бабки заплачены немалые.
Кстати сказать такой подход хоть и будет тормознутым, зато даст возможность легко подстраивать 1Л под изменения языка 1С в дальнейшем.</simpara>

</section>
</section>
<section>
<title>6410 ==</title>
<itemizedlist>
<listitem>
<simpara>
Global Module:
</simpara>
</listitem>
<listitem>
<simpara>
Вход:
</simpara>
</listitem>
<listitem>
<simpara>
текст
</simpara>
</listitem>
<listitem>
<simpara>
словарь системных методов, атрибутов и их методов
</simpara>
</listitem>
<listitem>
<simpara>
словарь predefined методов
</simpara>
</listitem>
<listitem>
<simpara>
Преобразование:
</simpara>
</listitem>
<listitem>
<simpara>
Converting(): Name export =&gt; e_Name | Name =&gt; __e_Name | Имя Экспорт =&gt; r_Imya | Имя =&gt; __r_Imya
</simpara>
</listitem>
<listitem>
<simpara>
Перем:
</simpara>
</listitem>
<listitem>
<simpara>
if (system attribute): error
</simpara>
</listitem>
<listitem>
<simpara>
else: Converting()
</simpara>
</listitem>
<listitem>
<simpara>
StatList =&gt; _init()
</simpara>
</listitem>
<listitem>
<simpara>
Function Name (a, b, val c) Export:
</simpara>
</listitem>
<listitem>
<simpara>
if (predefined_global): name = dict[name]
</simpara>
</listitem>
<listitem>
<simpara>
elif (keyword or system): error
</simpara>
</listitem>
<listitem>
<simpara>
else: Converting(); store src:dest    # т.е. речь о том, чтобы словари _никогда_ не пересекались - только в predefined
</simpara>
</listitem>
<listitem>
<simpara>
(&#8230;val c) =&gt; (&#8230;c) - или придумать механизмы. Как варианты:
</simpara>
</listitem>
<listitem>
<simpara>
a, b = Name(a, b, val c)
</simpara>
</listitem>
<listitem>
<simpara>
a = globalstorage(1); b = globalstorage(2); Name(a, b)
</simpara>
</listitem>
<listitem>
<simpara>
Var e, f =&gt; e = None; f = None
</simpara>
</listitem>
<listitem>
<simpara>
вызовы глобальных переменных (но _не_ аргументов и _не_ Var) - предварить "global &#8230;"
</simpara>
</listitem>
<listitem>
<simpara>
вызовы к системным членам - по словарю (?)
</simpara>
</listitem>
<listitem>
<simpara>
Выход:
</simpara>
</listitem>
<listitem>
<simpara>
словарь переменных export (старое и новое имя)
</simpara>
</listitem>
<listitem>
<simpara>
словарь методов export
</simpara>
</listitem>
<listitem>
<simpara>
misc
</simpara>
</listitem>
<listitem>
<simpara>
maybe словарь системных - 3 части:
</simpara>
</listitem>
<listitem>
<simpara>
атрибуты (Name | Name\.*)
</simpara>
</listitem>
<listitem>
<simpara>
ф-ции (Name(*)
</simpara>
</listitem>
<listitem>
<simpara>
методы атрибутов (\.Name())
</simpara>
</listitem>
</itemizedlist>
<section>
<title>mybuh</title>
<section>
<title>nota_bene.txt</title>
<itemizedlist>
<listitem>
<simpara>
создаем class FormControlElem - объект в котором хранится информация об одном контроле(элементе формы), взятая из Dialog Stream ert-модуля
</simpara>
</listitem>
<listitem>
<simpara>
//// с числами не все так просто &#8230;. пример:
    R_a = 2.356
    R_a = R_a + 3.897; #
    R_a = R_a - 4.14; #
    R_a = R_a * 5; #
    R_a = R_a / 10.0; #
    #Сообщить(А)
    #print R_a,type(R_a) здесь print показывает 1.0565, но сравнение не проходит, если убрать round !!!!!
    R_a = round(R_a,4)
    #print R_a,type(R_a)
</simpara>
<literallayout class="monospaced">    if ( R_a != 1.0565 ):
        Buh.Message("КЯ:012:Неверный результат математических вычислений" + Buh.String(R_a))
  нужно учитывать при конвертации...
  и что главное - даже если поставить round(...,15) - уже проходит...
* ГЛЮК СО СЛОЖЕНИЕМ СТРОК В ПИТОНЕ:
  StrOfQuery = "UPDATE " + self.CurrSpecifier.TblName + " SET "
    print StrOfQuery + "*****фы"
  выбрасывает ошибку (не всегда):
    UnicodeDecodeError: 'ascii' codec can't decode byte 0xf4 in position 5: ordinal not in range(128)
  ЛЕЧИТСЯ:
    print str(StrOfQuery) + str("*****фы")
* РАБОТА С ФОРМОЙ (диалогом).
  Так как не получится сделать как в 1С (например, если на форме есть поле "Цена"), то из модуля можно делать :
  читать:
    ВремЦена = Цена
  и писать:
    Цена = 100.25),
  именно писать и не получится, так как будет создан новый объект и на форме ничего не изменится...
  ПОЭТОМУ !!!
  Делаем классы Dlg() и Tbl() для доступа к форме и таблице соответственно со своим контролем атрибутов...
  Поэтому после трансляции придется соответственно изменить исх. текст модуля.
  Т.е. вместо Цена = 100.25 будет Dlg.R_cena = 100.25
* Аналогично и с таблицей.
* 13.06.05 Сделан спец.контрол buh_tbctrl.TextBtnCtrl - текстовое поле с кнопкой для выбора значений "бух" - типов данных.
  ВНИМАНИЕ! Его нельзя размещать на модальных диалогах - в Линуксе он не перехватывает фокус и в итоге не воспринимает ввод с мыши и клав-ры
* было выполнено тестирование sqlite и pysqlite1.16 с pdo и без.
* Проблема - даже при указании типа поля BIGINT UNSIGNED записать число больше 10 разрядов (1234567890) не получается(пишет но выводит потом неверно).
  Поэтому sqlite подойдет только для небольших баз (примерно до 10 млн.строк в одной таблице, с учетом что два последних знака - BaseID, т.е. код базы)
* было выполнено тестирование PostgreSQL8.0 и PyGreSQL-3.6.1 с pdo и без.
  Проблема - для BIGINT не понимает UNSIGNED
* Также проблема с кавычками.
  Так неправильно:
    db.execute('INSERT INTO t5 (o_id, f01) VALUES(1234567890, "apple")')
  а так правильно:
    db.execute("INSERT INTO t5 (o_id, f01) VALUES(1234567890, 'apple')")</literallayout>
</listitem>
</itemizedlist>
</section>
<section>
<title>translating.txt</title>
<itemizedlist>
<listitem>
<simpara>
поубирал все периодические константы и реквизиты справочников&#8230;
</simpara>
</listitem>
<listitem>
<simpara>
поубирал слои на формах&#8230;
</simpara>
</listitem>
<listitem>
<simpara>
Атрибут документа Операция использовать ТОЛЬКО в модуле проведения
</simpara>
</listitem>
</itemizedlist>
</section>
<section>
<title>transl_specif.txt</title>
<itemizedlist>
<listitem>
<simpara>
Перед трансляцией подобавлять в модулях по одной пустой строке в конце текста программного модуля, иначе если конец файла находится в непустой строке - то глюки при трансляции этого модуля
</simpara>
</listitem>
<listitem>
<simpara>
Желательно оставить только русские ключевые слова. Английские поубирать.
</simpara>
</listitem>
<listitem>
<simpara>
В самом простом описании транслятор переводит русские 1С-ключевые слова в английские 1С-ключевые слова согласно "описанию встроенного языка". Русские идентификаторы переменных переводятся методом транслитерации в английские с добавлением префикса "R_". Возможно, в-дальнейшем, этот префикс не будет добавлятся в случае, если переведенный идентификатор "не пересекается" с ключевыми словами. Нужно подумать&#8230;
</simpara>
</listitem>
<listitem>
<simpara>
В модулях формы к идентификаторам элементов диалога добавляется префикс "dlg.", а к идентификаторам табличной части диалога добавляется префикс "tbl.".
</simpara>
</listitem>
<listitem>
<simpara>
В модулях проведения документов и к идентификаторам элементов диалога , и к идентификаторам табличной части диалога добавляется префикс "Context."
</simpara>
</listitem>
<listitem>
<simpara>
Во все модулях кроме глобального, к идентификаторам функций и переменных, которые экспортируются из глоб.модуля, добавляется префикс "glob_mod."
</simpara>
</listitem>
<listitem>
<simpara>
глобальные переменные (описанные в блоке Перем модуля) не нужно передавать в качестве аргументов функций, на то они и глобальные, меньше путаницы&#8230;
</simpara>
</listitem>
<listitem>
<simpara>
а ссылочные аргументы в 1С нужно переделать так:
  было :
        Если Функ(А1,А2) = 10 тогда
                А3 = А1 + А2
        КонецЕсли;
  переделываем:
        Рез = Функ(А1,А2);
        Если Рез = 10 тогда
                А3 = А1 + А2
        КонецЕсли;
  Мелочь, но зато головняка намного меньше&#8230;
</simpara>
</listitem>
<listitem>
<simpara>
Желательно, там где можно в функциях с параметрами ставить "Знач", особенно когда параметров много.
</simpara>
</listitem>
<listitem>
<simpara>
Функции Мин и Макс заменяются на Питоновские, которые не преобразовуют типы к одному виду, поэтому например 123 и "345" сравниваются не так как в 1С&#8230;
</simpara>
</listitem>
<listitem>
<simpara>
Строковые функции AnsiToOem и OemToAnsi - не работают, возвращают исх. строку
</simpara>
</listitem>
<listitem>
<simpara>
Тело модуля 1С (которое внизу, после всех процедур и функций) не обрабатывается, поэтому в исх. конфах его нужно переместить в процедуру ПриОткрытии()
</simpara>
</listitem>
<listitem>
<simpara>
блок :
        Если сз.Принадлежит("Значение444") = 1 тогда
                //Сообщить("СЗ: Проверка на принадлежность строкового значения - успешно&#8230;");
        иначе
                Сообщить("СЗ:098: Проверка на принадлежность строкового значения - неверно !!!");
        КонецЕсли;
  преобразуется в :
        if ( R_sz.Belong("""Значение444""") == 1 ):
                #Сообщить("СЗ: Проверка на принадлежность строкового значения - успешно&#8230;")
        else:
                bMessage("""СЗ:098: Проверка на принадлежность строкового значения - неверно !!!""")
  что выдает ошибку после строки с if (нужен какой-нибудь оператор)&#8230;
  исправляем :
        Если сз.Принадлежит("Значение444") = 1 тогда
                ПустаяПеременная = 0;
                //Сообщить("СЗ: Проверка на принадлежность строкового значения - успешно&#8230;");
        иначе
                Сообщить("СЗ:098: Проверка на принадлежность строкового значения - неверно !!!");
        КонецЕсли;
</simpara>
</listitem>
<listitem>
<simpara>
опущенные аргументы функций при вызове :
        f3(1,,1)
  будут заменятся на None
        f3(1,None,1)
  потому что Питон не допускает пропущенных аргументов&#8230;
</simpara>
</listitem>
<listitem>
<simpara>
&#8230;
        Функция РасчетНадбавки (СтараяЦ,ПроцН) Экспорт
                // ________ Функция возвращает новую сумму с учетом старой и процента надб./скидки
                Если ПроцН = 0 тогда
                        Возврат СтараяЦ;
                Иначе Возврат СтараяЦ<emphasis role="strong">(100+ПроцН)/100;
                КонецЕсли;
        КонецФункции
  переделываем:
        Функция РасчетНадбавки (Знач СтараяЦ, Знач ПроцН) Экспорт
                // Функция возвращает новую сумму с учетом старой и процента надб./скидки
                Если ПроцН = 0 тогда
                        Возврат СтараяЦ;
                Иначе
                        Возврат СтараяЦ</emphasis>(100+ПроцН)/100;
                КонецЕсли;
        КонецФункции
</simpara>
</listitem>
<listitem>
<simpara>
&#8230;
        Если СокрЛП(ВРег(зн))&lt;&gt;"ааа" Тогда
                Возврат 0;
        Иначе
  переделываем--- :
        Если СокрЛП(ВРег(зн)) &lt;&gt; "ааа" Тогда
                Возврат 0;
        Иначе
</simpara>
</listitem>
<listitem>
<simpara>
&#8230;
        Str0 = "Добро пожаловать! Сегодня " + ДеньНеделиПрописью(ТекущаяДата())
        + " " + ТекущаяДата() + РазделительСтрок +"Сейчас установлен  курс УДЕ="
        + Вв.Курс.Получить(ТекущаяДата());
  переделываем--- :
        Str0 = "Добро пожаловать! Сегодня " + ДеньНеделиПрописью(ТекущаяДата()) ;
        Str0 = Str0 + " " + ТекущаяДата() + РазделительСтрок +"Сейчас установлен  курс УДЕ=" ;
        Str0 = Str0 + Вв.Курс.Получить(ТекущаяДата());
</simpara>
</listitem>
<listitem>
<simpara>
&#8230;
        Сообщить("Документ " + Конт.Вид() + " № " + Конт.НомерДок
        <indexterm>
  <primary> от </primary>
</indexterm>
 от Конт.ДатаДок+" не проводится!!!");
  переделываем--- :
        Стр2 = "Документ " + Конт.Вид() + " № " + Строка(Конт.НомерДок) ;
        Стр2 = Стр2 + " от " + Строка(Конт.ДатаДок) + " не проводится!!!";
        Сообщить(Стр2);
</simpara>
</listitem>
<listitem>
<simpara>
если в модуле встречается :
        НужнаяСтр = """ЗначениеСЗ555""" + ",";
  заменяем на:
        К = Симв(34); // двойные кавычки
        НужнаяСтр = К + "ЗначениеСЗ555" + К + ",";
  транслятору станет намного легче&#8230;
</simpara>
</listitem>
<listitem>
<simpara>
Если в тексте для Таблицы Значений встречается:
        тз.ПолучитьПараметрыКолонки("КолЧисло",,ПеремДлина,ПеремТочн);
  нужно поставить:
        а = тз.ПолучитьПараметрыКолонки("КолЧисло",,ПеремДлина,ПеремТочн);
  Потому как там много необязательных параметров, которые передаются по ссылке&#8230; транслятор путается&#8230; :-(
</simpara>
</listitem>
<listitem>
<simpara>
&#8230;
        Если сз.НайтиЗначение("Значение444") = 2 тогда
  меняем на
        Рез = сз.НайтиЗначение("Значение444");
        Если Рез = 2 тогда
</simpara>
</listitem>
<listitem>
<simpara>
&#8230;
        тз.ВыбратьСтроку(ВыбСтр,"Выбор строки в таблице&#8230;");
  меняем на
        Рез = тз.ВыбратьСтроку(ВыбСтр,"Выбор строки в таблице&#8230;");
</simpara>
</listitem>
</itemizedlist>
</section>
</section>
</section>
<section>
<title>Проверить</title>
<section>
<title>Python</title>
<itemizedlist>
<listitem>
<simpara>
можно ли вставлять свои простые переменные в global
</simpara>
</listitem>
<listitem>
<simpara>
можно ли импортировать модуль _не_ из файла
</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section>
<title>Vocabulary</title>
<itemizedlist>
<listitem>
<simpara>
aim == цель
</simpara>
</listitem>
<listitem>
<simpara>
vocabulary == словарь
</simpara>
</listitem>
<listitem>
<simpara>
ident == отступ
</simpara>
</listitem>
<listitem>
<simpara>
strategic == Стратегическая
</simpara>
</listitem>
<listitem>
<simpara>
tactic == Тактическая
</simpara>
</listitem>
<listitem>
<simpara>
objects == Объекты
</simpara>
</listitem>
<listitem>
<simpara>
global == Глобальные
</simpara>
</listitem>
<listitem>
<simpara>
Form == Форма
</simpara>
</listitem>
<listitem>
<simpara>
PreProcessing == подготовка исподников к трансляции
</simpara>
</listitem>
</itemizedlist>
</section>
</article>
